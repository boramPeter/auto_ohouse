import google.generativeai as genai

API_KEY_ENV_VARIABLE = 'AIzaSyBsKkgCQy0rb4sJzaZYp8WnhKmqu5PQ9-U'

MODEL_NAME = 'models/gemini-2.5-flash'
#

def configure_gemini():
    genai.configure(api_key=API_KEY_ENV_VARIABLE)
    model = genai.GenerativeModel(MODEL_NAME)
    print(f"Gemini 모델 '{MODEL_NAME}'이(가) 성공적으로 초기화되었습니다.")
    return model


def get_base_prompt_template_text() -> str:
    prompt_text = (
        """\
            # 페르소나:
            당신은 소프트웨어 테스트 문서를 깊이 이해하고 분석하여, 실제 수행해야 할 테스트 스코프(개별 검증 항목)를 문장 단위로 정확하게 추출하는 AI 전문가입니다.
            
            # 목표:
            주어진 텍스트 문서에서 개발된 기능이나 시스템이 의도대로 동작하는지 검증하기 위한 구체적인 테스트 항목들을 문장 단위로 식별하고, 각 문장을 개별 청크(chunk)로 만들어 주십시오. 이 청크들은 향후 벡터 데이터베이스(vector DB)에서 유사 테스트 케이스를 검색하는 데 활용될 것입니다.
            
            # 추출 지침:
            1.  **문맥 중심의 스코프 식별**: 각 문장을 면밀히 검토하여, 해당 문장이 특정 기능의 동작, 상태 변화, UI 표현, 데이터의 정합성 등을 검증하는 내용을 담고 있는지 문맥을 통해 종합적으로 판단합니다.
            2.  **독립적이고 명확한 검증 단위**: 추출된 각 문장(청크)은 그 자체로 하나의 완전하고 독립적인 테스트 검증 항목으로서 의미가 명확해야 합니다.
            3.  **테스트 스코프 문장의 특징 (예시)**:
                * 사용자의 특정 행동(Action)에 따른 시스템의 예상 결과(Expected Result)를 기술하는 문장 (예: "로그인 버튼 클릭 시 메인 화면으로 이동하는지 검토")
                * 특정 조건(Condition) 하에서 시스템이 올바르게 반응하거나 상태를 표시하는지 기술하는 문장 (예: "잘못된 비밀번호 입력 시 오류 메시지가 표시되는지 확인", "데이터 로딩 중 스피너 애니메이션이 나타난다")
                * UI 요소의 정확한 노출, 스타일, 상호작용 등을 기술하는 문장 (예: "홈 화면 상단에 '오늘의 취향' 탭이 정상적으로 노출되어야 한다", "검색 결과는 2-grid 폭포수 형태로 표시된다")
                * **주의**: 문장 끝이 반드시 '확인', '검증' 등으로 끝나지 않아도 됩니다. 내용상 검증 항목으로 판단되면 추출 대상입니다.
            4.  **제외 대상**:
                * 테스트 스코프를 설명하기 위한 부가적인 문장, 도입부, 일반적인 설명, 배경 정보 (예: "다음은 기능 테스트 결과입니다.", "이 섹션에서는 UI 관련 사항을 점검합니다.")
                * "산정 이유:", "목표:", "개요:", "참고:" 등과 같이 테스트 스코프 자체가 아닌 보조 정보나 섹션 제목.
                * 개발자의 주석, 질문, 단순 의견, 또는 모호하거나 추상적인 기술.
            5.  **구조적 유연성**: 테스트 스코프는 "테스트 범위:", "검증 항목:" 등 특정 키워드 아래에 나열될 수도 있지만, 문서 본문 전체에 걸쳐 서술형으로 포함될 수도 있습니다. 특정 문서 구조에만 의존하지 않고 내용의 본질을 파악하여 스코프를 추출합니다.
            6.  **청킹 단위**: 각 테스트 스코프는 발견된 문장 단위로 청킹합니다. 즉, 하나의 검증 항목이 하나의 문장으로 구성되도록 합니다.
            
            # 출력 형식:
            추출된 각 테스트 스코프 문장(청크)을 별도의 줄에 나열해주십시오. 각 문장은 원본의 핵심 의미를 유지해야 하며, 불필요한 앞뒤 공백은 제거합니다.
            
            ---
            # 입력 예시 (사용자가 제공한 예시를 기반으로 함):
            
            세 번째 테스트 범위 시작
            1. '오늘의 취향' 탭 및 기본 화면 UI/UX 검증 (문서 User Story No. 1 관련)
            테스트 범위:
            홈 화면 상단에 '오늘의 취향' 탭이 정상적으로 노출되는지 확인
            탭 선택 시 지정된 폰트, Lottie 애니메이션, 타이틀 롤링 애니메이션(앱 세션당 4회)이 동작하는지 확인
            탭 선택 시 기본 피드 화면 구성(2-grid waterfall 형식 예상)이 정상적으로 노출되는지 확인
            산정 이유: 문서의 User Story No. 1에서 '오늘의 취향' 탭의 존재와 함께 폰트 변경, Lottie 애니메이션, 타이틀 롤링 애니메이션 등 구체적인 UI/UX 요구사항을 명시하고 있기 때문에, 이 부분들이 정확하게 구현되었는지 확인하는 것이 중요합니다. 피드 구성 자체는 명시적으로 2-grid라고 User Story에 나와있진 않지만, 다른 피드 관련 문서(첫 번째 예시)에서 2-grid를 기본으로 사용하고 있고, 이 문서의 필터 선택 결과도 2-grid로 노출된다는 설명(No. 3-1)을 통해 기본 피드 역시 2-grid임을 유추하여 포함했습니다.
            2. 집들이 모듈을 통한 '오늘의 취향' 피드 진입 및 랜딩 검증 (문서 User Story No. 2 관련)
            테스트 범위:
            홈 화면의 집들이 1-grid 모듈 UI 변경사항 확인 (타이틀, 메타 정보 노출 조건)
            메타 정보가 없는 집들이 모듈 클릭 시, '오늘의 취향' 피드의 '집들이' 필터가 선택되고 '최신순'으로 정렬된 상태로 랜딩되는지 확인 (P0)
            (제외 - P1): 메타 정보가 있는 집들이 모듈 클릭 시, '오늘의 취향' 피드의 '집들이', 특정 '가족형태', '평형대' 필터가 선택되고 '최신순'으로 정렬된 상태로 랜딩되는지 확인
            산정 이유: User Story No. 2는 홈 집들이 1-grid 모듈의 디자인 변경과 함께, 이 모듈을 통해 '오늘의 취향' 피드로 진입했을 때의 구체적인 랜딩 동작(필터 적용 상태)을 정의하고 있습니다. 특히 메타 정보 유무에 따른 랜딩 조건이 다르며, P0에 해당하는 '메타 정보가 없는 경우'의 랜딩 동작 검증이 필수적입니다. '메타 정보가 있는 경우'는 P1으로 명시되어 이번 버전에서는 제외되었습니다.
            3. '오늘의 취향' 피드 내 필터 영역 기능 검증 (문서 User Story No. 3, 3-1 관련)
            테스트 범위:
            피드 상단에 필터 영역이 정상적으로 노출되는지 확인
            필터 영역에 노출되는 필터 타입 확인 (주제, 공간, 평수, 가족형태, 주거형태)
            필터 바텀시트/모달 동작:
            '주제' 필터 클릭 시 주제 바텀시트가 노출되는지 확인 (큐레이션 주제, 집들이/집사진 유형 포함)
            '공간', '평수', '주거형태', '가족형태' 필터 클릭 시 필터 바텀시트가 노출되고, 클릭한 필터 영역으로 앵커링되는지 확인
            바텀시트 내에서 다른 필터 옵션도 선택 가능한지 확인
            바텀시트 하단의 '초기화' 버튼 클릭 시 모달은 유지되고 필터 옵션만 기본값으로 초기화되는지 확인
            필터 선택 결과:
            필터 선택 후 'CTA (콘텐츠 보기)' 클릭 시 선택한 필터 조건에 따라 2-grid 콘텐츠가 노출되는지 확인
            '주제' 필터에서 '큐레이션 주제' 선택 시, 문서에 명시된 콘텐츠 유형(cc, project, advice)만 필터링되어 노출되는지 확인
            '주제' 필터에서 '집들이' 또는 '집사진' 선택 시, 문서에 명시된 콘텐츠 유형(card, cc, Project, advice 제외)만 필터링되어 노출되는지 확인
            '집들이'/'집사진' 선택 후, 상단 필터 영역에 세부 필터(공간, 평수 등)가 노출되는지 확인 (문서에 명시된 순서 확인 필요)
            세부 필터 선택 시, 선택 내용이 필터 하단 영역에 노출되고 취소 가능한지 확인 (SRP 필터 액션과 동일)
            복수 필터 조합 (예: '집들이' + '원룸/오피스텔' + '10평 미만') 선택 시 정확한 필터링 결과가 노출되는지 확인
            필터 초기 상태 및 이동:
            피드 첫 진입 시 필터 영역의 기본 정렬이 '최신 인기순'으로 설정되어 있는지 확인 (문서 No. 3-1)
            필터 선택 후 피드 상단의 'X' 버튼 클릭 시 필터가 해제되고 '오늘의 취향' 홈(필터링되지 않은 상태)으로 이동하는지 확인
            산정 이유: (생략)
            4. 데이터 로깅 검증 (문서 '데이터 요건' 관련)
            테스트 범위:
            문서의 '데이터 요건' 섹션 또는 관련 링크/명세서에 정의된 Impresstion (노출) 및 Click (클릭) 이벤트가 정상적으로 수집되는지 확인 (예: 섹션, 오브젝트 타입, 오브젝트 ID, 오브젝트 인덱스 등)
            산정 이유: (생략)
            ---
            
            # 기대 출력 (위 입력 예시에 대한):
            홈 화면 상단에 '오늘의 취향' 탭이 정상적으로 노출되는지 확인
            탭 선택 시 지정된 폰트, Lottie 애니메이션, 타이틀 롤링 애니메이션(앱 세션당 4회)이 동작하는지 확인
            탭 선택 시 기본 피드 화면 구성(2-grid waterfall 형식 예상)이 정상적으로 노출되는지 확인
            홈 화면의 집들이 1-grid 모듈 UI 변경사항 확인 (타이틀, 메타 정보 노출 조건)
            메타 정보가 없는 집들이 모듈 클릭 시, '오늘의 취향' 피드의 '집들이' 필터가 선택되고 '최신순'으로 정렬된 상태로 랜딩되는지 확인 (P0)
            (제외 - P1): 메타 정보가 있는 집들이 모듈 클릭 시, '오늘의 취향' 피드의 '집들이', 특정 '가족형태', '평형대' 필터가 선택되고 '최신순'으로 정렬된 상태로 랜딩되는지 확인
            피드 상단에 필터 영역이 정상적으로 노출되는지 확인
            필터 영역에 노출되는 필터 타입 확인 (주제, 공간, 평수, 가족형태, 주거형태)
            '주제' 필터 클릭 시 주제 바텀시트가 노출되는지 확인 (큐레이션 주제, 집들이/집사진 유형 포함)
            '공간', '평수', '주거형태', '가족형태' 필터 클릭 시 필터 바텀시트가 노출되고, 클릭한 필터 영역으로 앵커링되는지 확인
            바텀시트 내에서 다른 필터 옵션도 선택 가능한지 확인
            바텀시트 하단의 '초기화' 버튼 클릭 시 모달은 유지되고 필터 옵션만 기본값으로 초기화되는지 확인
            필터 선택 후 'CTA (콘텐츠 보기)' 클릭 시 선택한 필터 조건에 따라 2-grid 콘텐츠가 노출되는지 확인
            '주제' 필터에서 '큐레이션 주제' 선택 시, 문서에 명시된 콘텐츠 유형(cc, project, advice)만 필터링되어 노출되는지 확인
            '주제' 필터에서 '집들이' 또는 '집사진' 선택 시, 문서에 명시된 콘텐츠 유형(card, cc, Project, advice 제외)만 필터링되어 노출되는지 확인
            '집들이'/'집사진' 선택 후, 상단 필터 영역에 세부 필터(공간, 평수 등)가 노출되는지 확인 (문서에 명시된 순서 확인 필요)
            세부 필터 선택 시, 선택 내용이 필터 하단 영역에 노출되고 취소 가능한지 확인 (SRP 필터 액션과 동일)
            복수 필터 조합 (예: '집들이' + '원룸/오피스텔' + '10평 미만') 선택 시 정확한 필터링 결과가 노출되는지 확인
            피드 첫 진입 시 필터 영역의 기본 정렬이 '최신 인기순'으로 설정되어 있는지 확인 (문서 No. 3-1)
            필터 선택 후 피드 상단의 'X' 버튼 클릭 시 필터가 해제되고 '오늘의 취향' 홈(필터링되지 않은 상태)으로 이동하는지 확인
            문서의 '데이터 요건' 섹션 또는 관련 링크/명세서에 정의된 Impresstion (노출) 및 Click (클릭) 이벤트가 정상적으로 수집되는지 확인 (예: 섹션, 오브젝트 타입, 오브젝트 ID, 오브젝트 인덱스 등)
            ---
            # <<< 분석 대상 문서 시작 >>>
            {actual_test_scope_document}
            # <<< 분석 대상 문서 끝 >>>
            """
    )
    return prompt_text.strip()

def extract_scopes_from_document(model: genai.GenerativeModel,
                                              test_scope_document: str) -> list[str]:
    """
    테스트 스코프 문서 전체를 '통으로' 입력받아 LLM으로 분석하고,
    추출된 테스트 스코프 문장들의 리스트를 반환합니다.
    get_base_prompt_template_text() 함수를 사용하여 프롬프트 템플릿을 가져옵니다.
    """
    extracted_scopes = []
    if not model:
        print("오류: 모델이 초기화되지 않아 처리를 중단합니다.")
        return extracted_scopes

    if not test_scope_document or not test_scope_document.strip():
        print("정보: 입력된 테스트 스코프 문서가 비어있거나 공백만 포함합니다. 처리를 중단합니다.")
        return extracted_scopes

    print(f"테스트 스코프 문서 전체 (약 {len(test_scope_document)}자) 분석을 시작합니다...")

    # get_base_prompt_template_text 함수를 호출하여 프롬프트 템플릿을 가져옴
    base_prompt_template = get_base_prompt_template_text()

    # 실제 문서 내용을 프롬프트 템플릿에 삽입
    prompt_for_llm = base_prompt_template.format(
        actual_test_scope_document=test_scope_document
    )

    try:
        # LLM 호출 (단일 요청으로 전체 문서 처리)
        response = model.generate_content(prompt_for_llm)

        # 응답이 비어있거나 (safety settings 등), 내용이 없는 경우 처리
        if not response.parts:
            print(f"LLM 응답이 비어있습니다 (예: safety settings). 스코프를 추출할 수 없습니다.")
            return extracted_scopes

        llm_output_text = response.text.strip()

        if not llm_output_text:
            print("LLM이 빈 결과를 반환했습니다. 추출된 스코프가 없습니다.")
            return extracted_scopes

        # LLM 응답은 각 스코프가 줄바꿈으로 구분되어 있을 것으로 예상
        # 각 줄의 앞뒤 공백을 제거하고, 빈 줄은 결과 리스트에서 제외
        extracted_scopes = [line.strip() for line in llm_output_text.splitlines() if line.strip()]

        if not extracted_scopes:
            print("LLM 응답에서 유효한 스코프를 찾지 못했습니다 (모든 라인이 비어있거나 응답 형식이 예상과 다를 수 있음).")
        else:
            print(f"처리 완료. 총 {len(extracted_scopes)}개의 테스트 스코프를 추출했습니다.")

    except Exception as e:
        print(f"문서 전체 분석 중 오류 발생: {e}")
        # 오류 발생 시 빈 리스트 반환

    return extracted_scopes

def format_scopes_for_embedding(
    scope_texts: list[str],
    start_index: int = 0
) -> list[dict]:
    """
    스코프 문자열 리스트를 받아 임베딩 및 관리에 용이한 딕셔너리 리스트로 변환합니다.
    """
    formatted_scopes = []
    if not scope_texts:
        print("정보: 포맷할 스코프 텍스트가 없습니다.")
        return formatted_scopes
    print(f"'{len(scope_texts)}개 스코프를 임베딩용 포맷으로 변환합니다...")
    for i, text_content in enumerate(scope_texts):
        scope_item = text_content

        formatted_scopes.append(scope_item)
    print(f"포맷 변환 완료. {len(formatted_scopes)}개 객체 준비.")
    return formatted_scopes


def run_scope_extraction(
    document_content: str) -> list[dict] | None:
    """
    테스트 스코프 추출 및 임베딩 준비를 위한 전체 파이프라인을 실행합니다.

    Args:
        document_content: 분석할 테스트 스코프 문서의 전체 텍스트 내용 (사용자 요청의 "스코프").
        document_id: 해당 문서의 식별자.

    Returns:
        임베딩을 위해 포맷팅된 스코프 딕셔너리 리스트.
        모델 초기화 실패 시 None, 스코프가 없거나 변환 실패 시 빈 리스트.
    """

    # 단계 1: Gemini 모델 초기화
    gemini_model = configure_gemini()
    if not gemini_model:
        print(f"'모델 초기화 실패. 파이프라인을 중단합니다.")
        return None # 모델 초기화 실패 시 None 반환

    # 단계 2: 문서에서 테스트 스코프 추출
    print(f"\n📄 스코프 추출 중...")
    extracted_scope_texts = extract_scopes_from_document(
        gemini_model,
        document_content
    )

    if not extracted_scope_texts: # 추출된 스코프가 없는 경우
        print(f"\n'문서에서 추출된 스코프가 없습니다. 파이프라인을 종료합니다.")
        return [] # 빈 리스트 반환

    print(f"\n👍 추출된 스코프 텍스트 ({len(extracted_scope_texts)}개):")
    for i, txt in enumerate(extracted_scope_texts):
        print(f"  {i+1}. \"{txt[:70]}{'...' if len(txt) > 70 else ''}\"") # 너무 길면 잘라서 표시

    # 단계 3: 추출된 스코프들을 임베딩 및 관리에 용이한 형태로 포맷팅
    print(f"\n✨ 추출된 스코프를 임베딩용 포맷으로 변환 중...")
    prepared_scopes = format_scopes_for_embedding(
        extracted_scope_texts,
    )

    # prepared_scopes가 빈 리스트일 수도 있으나, format_scopes_for_embedding 내부에서 로그 처리됨
    if prepared_scopes:
        print(f"\n✅ 임베딩을 위해 최종 준비된 스코프 데이터 ({len(prepared_scopes)}개).")
    else: # 이 경우는 extracted_scope_texts는 있었으나 포맷팅 결과가 빈 경우 (일반적으론 발생 안함)
        print("\n⚠️ 임베딩용 포맷으로 변환된 스코프가 없습니다.")
        return []

    print(f"\n🏁 파이프라인 완료: 🏁")
    return prepared_scopes

if __name__ == "__main__":
    print("===== 테스트 스코프 처리 파이프라인 실행 시작 =====")
#     sample_document_scope_content = """
#     네, 세 번째 문서("PRD_크리에이터 등급 프로그램 도입")와 그 테스트 범위 산정 이유를 잘 학습했습니다. 문서에서 주요 기능 및 구성 요소를 파악하고, 이를 바탕으로 어떤 종류의 테스트 항목이 도출되는지 이해했습니다.
#
# 이제 제공해주신 새로운 문서 **"[SpecDocs] 24H2_Price - 특가 정책 관리 시스템"**을 꼼꼼히 분석하여, 학습한 패턴을 적용해 테스트 범위를 산정하겠습니다.
#
# 새 문서 분석 및 테스트 범위 산정:
#
# 이 문서는 "특가 정책 관리 시스템"의 기술 요건 및 정책을 정의하고 있습니다. 핵심은 네이버 최저가와 오늘의집 상품 가격을 비교하여 자동으로 '특가' 뱃지를 관리하고, MD/운영자가 수동으로 정책을 생성하고 관리하며, 이 과정에서 검수 절차를 도입하는 것입니다.
#
# 문서의 주요 내용 및 구성 요소를 바탕으로 다음과 같은 테스트 범위를 도출할 수 있습니다.
#
# 자동 가격 비교 및 배지 노출 로직 검증 (System)
#
# 데이터 동기화: 네이버 원부/최저가 정보(전체EP, 요약EP)가 주기적으로(일/시간 단위) 오늘의집 DB에 정상적으로 적재되는지, 적재 실패 시 이전 데이터를 활용하는 예외 정책이 동작하는지 확인합니다. (S.1)
# 오늘의집 가격 산정: 특가 비교 기준이 되는 오늘의집 상품 가격이 대표옵션 기준으로 정확하게 계산되는지 확인합니다. (할인액, 상품쿠폰 할인액 포함, 장바구니/결제 할인 제외) (S.2, Requirement 9)
# 네이버 최저가 정의: 네이버 원부 ID 기반으로 수집된 최저가 데이터(lowest_price, lowest_delivery_cost)를 정확하게 가져오는지 확인합니다. (S.2)
# 가격 비교 로직: 오늘의집 가격과 네이버 최저가를 비교하는 핵심 로직이 배송비 조건(선불/무료, 착불, 혼합)에 따라 정확하게 수행되는지 검증합니다. (S.2, Requirement 9)
# 배송비 모두 선불/무료 시 비교
# 배송비 착불 존재 시 비교 (원부/OH 모두 착불, 원부 모두 착불/OH 선불, 원부 선불/OH 착불 케이스)
# 상품 상태(판매중), 대표옵션 상태(판매중), 재고(>0) 조건을 만족하지 않는 상품의 비교 로직 제외 여부를 확인합니다. (S.2)
# 현재 적용 중인 Black/White/Gray 정책에 따른 비교 로직 제외 여부를 확인합니다. (S.2)
# 최저가 정보가 없는 상품의 비교 로직 제외 여부를 확인합니다. (S.2)
# 자동 Badging/Debadging: 가격 비교 결과에 따라 상품에 '특가' 뱃지가 자동으로 Badging(부여)되거나 Debadging(해제)되는지 검증합니다. (S.2, S.8, Requirement 8, 9)
# Badging 조건 충족 시 자동 부여
# Debadging 조건 충족 시 자동 해제 (가격 변동, 판매 상태 변경 등)
# 어드민에서 설정/승인된 상품의 자동 Badging/Debadging 예외 처리 로직을 확인합니다. (Requirement 12)
# Blacklist 정책 적용: Blacklist로 관리되는 상품은 가격 조건과 무관하게 무조건 Badging이 불가한지 검증합니다. (Requirement 11, 12)
# 정책 및 검수 시스템 워크플로우 검증 (System)
#
# 요청 기반 검수서 생성: Gray 타입의 특가 요청 생성 시 검수서가 자동으로 생성되는지 검증합니다. (S.3)
# 정책 활성화 로직 (요청 기반): 특가 요청의 정책 시작일시가 도래하고, 연결된 검수서 결과가 '검수 성공'일 경우 해당 정책이 활성화(특가 뱃지 부여)되는지 검증합니다. (S.4)
# 정책 활성화 시점에 상품 상태, 대표옵션 상태/재고 조건, 옵션 번호 일치 여부 Validation Check가 정상 동작하는지 확인합니다. (S.4)
# 반복 검수서 자동 생성: 현재 활성화된 Gray 정책 중 특정 조건(오늘 +1일 활성 시간 24H 등)을 만족하는 정책에 대해 매일 자정(00시)에 반복 검수서가 자동으로 생성(또는 상태 변경)되는지 검증합니다. (S.5)
# 검수 결과에 따른 정책 제어:
# 검수 결과 'Pass' 시 특가 정책 상태(및 요청서 상태)가 '검수 성공'으로 변경되는지 검증합니다. (S.6)
# 검수 결과 'Fail' 시 해당 Gray 정책이 종료 처리되는지 검증합니다. (S.6)
# 최초 검수 실패 건에 대해 검수서가 재생성되는 로직을 검증합니다. (S.6)
# 검수 실패 알림 (Slack) 발송 검증 (System)
#
# 발송 조건: Gray 정책에 대한 검수(최초/반복) 결과가 'Fail'이고, 요청 분류가 '스오딜'인 경우에만 슬랙 알림이 발송되는지 검증합니다. (S.7)
# 발송 시점: 검수 실패 즉시 알림이 발송되는지, 또는 지정된 주기(오전 10시~저녁 7시, 1시간 간격)에 취합하여 발송되는지 확인합니다. (문서상 두 가지 시점이 언급되어 있어 명확한 기준 확인 필요) (S.7)
# 알림 내용: 슬랙 메시지에 상품 정보, debadging 사유(최저가 미만족), 후속 조치 가이드 등이 정확하게 포함되는지 검증합니다. (S.7)
# 발송 대상: 상품 담당 MD 그룹에게 정확하게 알림이 발송되는지 확인합니다. (S.7)
# 수동 정책 요청 생성 및 관리 (Admin)
#
# 요청 생성: 어드민에서 특정 상품의 특가 정책(Black, White, Gray) 생성 요청이 가능한지 검증합니다. (A.1)
# 필수 입력값(상품번호, 정책 타입, 시작일시 등) 누락 시 저장 불가, Validation 메시지 노출 여부를 확인합니다. (A.1, 특가요청(서) 데이터 정책)
# 상품번호, 옵션번호, 모음전번호의 존재 여부 및 유효성(판매 상태 등) Validation을 확인합니다. (A.1, 특가요청(서) 데이터 정책)
# 정책 시작일시/종료일시 입력 형식 및 기간 Validation(최대 7일)을 확인합니다. (A.1, 특가요청(서) 데이터 정책)
# 동일 상품/정책 타입에 대한 기간 중복 요청 생성 불가 로직을 확인합니다. (A.1)
# 요청자(어드민 유저 식별자), 요청 분류가 자동으로 입력되는지 확인합니다. (A.1, 특가요청(서) 데이터 정책)
# 요청 수정/취소: '대기' 상태의 요청만 수정/취소 가능한지, 수정 시 Validation이 동일하게 적용되는지 검증합니다. (A.1, A.2)
# 요청 목록 조회: 다양한 검색 조건(ID, 상품번호, 샵명/ID, 정책 타입 등)으로 특가 요청 목록 조회가 가능한지, 검색 결과(필드, 링크, 페이징)가 정확한지 검증합니다. (A.2)
# 다건 검색(콤마, 줄바꿈 구분) 기능이 정상 동작하는지 확인합니다. (A.2)
# 일괄 처리 (요청):
# CSV 양식 다운로드 및 양식에 맞춰 파일 업로드가 가능한지 검증합니다. (A.3, A.4)
# 일괄 업로드 시 Validation(기간 중복 등) 실패 건을 별도 오류 파일로 제공하는지 확인합니다. (A.3)
# 선택한 요청 또는 전체 검색 결과에 대해 일괄 다운로드가 가능한지 검증합니다. (A.4)
# 선택한 '대기' 상태 요청에 대해 일괄 취소가 가능한지 검증합니다. (A.2)
# 수동 검수 처리 (Admin)
#
# 검수서 조회: 어드민에서 생성된 특가 검수서 목록 조회가 가능한지 검증합니다. (A.7, A.8)
# 검색 조건 (ID, 상품번호, 정책 타입(Gray), 검수 상태 등) 및 검색 결과(필드, 링크, 페이징)가 정확한지 검증합니다. (A.8)
# 다건 검색(콤마, 줄바꿈 구분) 기능이 정상 동작하는지 확인합니다. (A.8)
# 단건 검수 처리: 검수 상세 화면에서 검수 상태(성공/실패) 지정, 근거 URL/가격/메모 입력이 가능한지 검증합니다. (A.7)
# 검수 완료 시 검수자(어드민 유저), 검수 시점이 자동으로 기록되는지 확인합니다. (A.7, 특가검수(서) 데이터 정책)
# 이전에 동일 상품/옵션에 입력된 근거 정보가 자동으로 불러와지는 편의 기능이 동작하는지 확인합니다. (A.7)
# 상품 정보, 네이버 가격 비교 URL(클릭 시 이동 확인) 등 참고 정보가 정확하게 표시되는지 확인합니다. (A.7)
# 검수 상태 변화: 어드민 검수 처리(성공/실패)에 따라 검수서 상태가 정확하게 변경되는지, '대기' 상태에서만 수정 가능한지 검증합니다. (A.7, 특가검수(서) Flow Chart)
# 일괄 처리 (검수):
# 선택한 검수 또는 전체 검색 결과에 대해 일괄 다운로드가 가능한지 검증합니다. (A.8)
# 일괄 업로드 양식을 활용하여 '대기' 상태 검수서의 수정 가능한 컬럼에 대해 일괄 수정 업로드가 가능한지 검증합니다. (A.8)
# 검수 배분 및 연속 처리 기능 (Admin)
#
# 검수 배분: 검색된 '검수대기' 상태 검수서를 선택하고, 특정 검수 담당자에게 지정된 개수만큼 배분하는 기능이 정상 동작하는지 검증합니다. (A.5)
# 요청 분류별 검수서 개수 확인 및 배분 대상 선택 기능 검증합니다. (A.5)
# 총 개수 입력 시 각 요청 분류별 개수 분배 로직이 예상대로 동작하는지 확인합니다. (A.5)
# 수동 배분(검수 담당자 지정) 기능이 정상 동작하는지 확인합니다. (A.5)
# 기존 배분 정보 덮어쓰기 로직을 확인합니다. (A.5)
# 연속 검수: 특정 검수 담당자에게 할당된 '검수대기' 상태 검수서를 목록으로 돌아오지 않고 연속해서 처리할 수 있는 기능이 정상 동작하는지 검증합니다. (A.6)
# 연속 검수 시작 시 검수자 유효성 검증을 확인합니다. (A.6)
# 현재 검수서 저장 후 할당된 다음 검수서로 자동 이동하는 로직을 확인합니다. (A.6)
# 할당된 검수서가 더 이상 없을 때 종료 메시지 및 목록 페이지 이동을 확인합니다. (A.6)
# 새로운 특가 뱃지 관리 메뉴 (어드민 UI) 기능 검증
#
# 메뉴 접근 및 현황: 레거시 메뉴가 사라지고(fade-out), 새로운 '특가 뱃지 관리' 메뉴가 오픈되는지 확인합니다. (Requirement 1) 메뉴 진입 시 최저가 자동 Badging/Debadging 개수, 승인 완료 Badging 개수 등 현황 정보가 노출되는지, 각 현황 클릭 시 목록이 필터링되는지 확인합니다. (Requirement 12)
# 조회 조건: 새로운 메뉴의 조회 조건(관리카테고리, 판매상태, 상품명, 특가 뱃지 노출 상태 등) 및 다건 검색 기능이 정상 동작하는지 검증합니다. (Requirement 12)
# 블랙리스트 관리: 목록에서 상품 선택 후 'badging 불가' 등록/해제 기능이 정상 동작하는지, 등록 시 확인 모달/메시지, 상태 변경(badging 가능여부=N)이 정확한지 검증합니다. (Requirement 12)
# 수동 뱃지 설정 (승인 요청): '미노출', 'badging 가능여부=Y' 상태 상품만 일괄 설정 가능한지, 설정 팝업(상품 정보, 기간 설정) 노출, 기간 설정 Validation(최대 7일, 시작일 이전 불가) 확인합니다. 설정 완료 시 상태가 '승인요청'으로 변경되는지 검증합니다. (Requirement 12)
# 수동 뱃지 승인/거절: '승인요청' 상태 상품에 대해 '승인', '거절' 처리가 가능한지 검증합니다. (Requirement 12)
# 승인 시 확인 모달/메시지, 상태 변경('노출중'), 버튼 변경('설정' → '해제')이 정확한지 확인합니다.
# 거절 시 사유 입력 팝업, 확인 모달/메시지, 상태 변경('미노출')이 정확한지 확인합니다.
# 승인/거절 처리 이력(처리일자, 변경 내용, 처리자, 거절 사유)이 정확하게 기록되는지 검증합니다.
# 특수 권한이 있는 사용자만 승인/거절/설정 가능한지 확인합니다.
# 수동 뱃지 해제: '노출중' 상태 상품에 대해 '해제' 버튼 클릭 시 확인 모달/메시지, 상태 변경('미노출'), 즉시 Debadging이 정확한지 검증합니다. (Requirement 12)
# 엑셀 다운로드: 조회 결과 목록을 엑셀로 다운로드하는 기능이 정상 동작하는지 검증합니다. (Requirement 12)
# 조회 결과 목록 상세 항목: 각 상품별로 노출되는 항목(뱃지 설정 버튼 상태, badging 가능여부, 노출 상태, 기간, 가격 정보, 배송비, MD 그룹, 카테고리, 네이버 정보, 최저가 여부, 기준일자, 변경이력 등)의 정확성 및 표시 형식을 검증합니다. (Requirement 12)
# 네이버 가격비교 URL 클릭 시 네이버 원부 페이지로 이동하는지, 원부 미매칭 상품의 URL 입력 기능이 정상 동작하는지 확인합니다.
# 네이버 최저가/배송비(-1 착불 표시), 네이버 가격비교 랭킹, 오늘의집 최저가 여부 표시의 정확성을 검증합니다.
# 변경 이력 상세보기 팝업에서 정보(처리일자, 내용, 사유, 처리자(시스템 포함))가 정확하게 노출되는지 확인합니다.
# 특가 정책 이력 조회 (Admin)
#
# 다양한 검색 조건(ID, 상품번호, 정책 타입, 상태, 시작/종료일시 등)으로 특가 정책 이력 목록 조회가 가능한지, 검색 결과(필드, 링크, 페이징)가 정확한지 검증합니다. (A.9)
# 다건 검색(콤마, 줄바꿈 구분) 기능이 정상 동작하는지 확인합니다. (A.9)
# 일괄 다운로드가 가능한지 검증합니다. (A.9)
# 백도어성 정책 종료 버튼 기능이 필요한 경우 해당 기능의 동작 및 권한을 검증합니다. (A.9)
# 일괄 처리 현황 조회 (Admin)
#
# 특가 요청 일괄 생성/수정, 특가 검수 일괄 수정, 특가 정책 종료 등 일괄 작업의 현황 및 결과를 조회할 수 있는지 검증합니다. (A.10)
# 정책 타입별 동작 및 데이터 무결성 검증
#
# Black, White, Gray, System 각 정책 타입이 정의된 대로 동작하는지, 우선순위에 따라 올바른 정책이 적용되어 뱃지 상태에 영향을 미치는지 검증합니다. (Policy, Requirement 11)
# 모든 엔티티(정책, 요청서, 검수서)의 필수 필드 및 데이터 타입 정의가 준수되는지, 데이터 저장 시 Validation이 정확하게 적용되는지 검증합니다. (데이터 정의 섹션, A.1, A.7)
# 정책의 선분 이력 관리 로직(종료일시 변경 등)이 정상 동작하는지 확인합니다. (Policy, 특가 정책 데이터)
# 워크플로우 상 정의된 상태 값 외의 상태로 변경되거나 비정상적인 흐름이 발생하지 않는지 확인합니다. (Policy, Request, Inspection Flow Charts)
# 이상의 테스트 범위는 문서에 명시된 주요 기능, 정책, 시스템 컴포넌트 및 어드민 기능을 포괄하도록 산정되었습니다. 문서 버전(ver 3.0)을 기준으로 하였으며, 각 항목별로 상세한 테스트 케이스는 이 범위를 기반으로 작성하게 됩니다.
#
# 어떠신가요? 이 학습 내용을 바탕으로 다른 문서를 제공해 주시면, 동일한 방식으로 분석하여 테스트 범위를 도출해 드리겠습니다.
#
#
#     """
#
#     # 러너 함수 호출
#     result = final_data_for_embedding = run_scope_extraction(
#         document_content=sample_document_scope_content,  # "스코프" 인자 전달
#     )
#
#     print (result)